---
type NotificationRecord = {
  id: string;
  title: string;
  body: string;
  lido: number | boolean;
  lido_em?: string | null;
  created_at?: string | null;
  grupo_id?: string | null;
  grupo_slug?: string | null;
  mensagem_id?: string | null;
  mensagem_is_secret?: number | boolean | null;
};

const env =
  Astro.locals.cloudflare?.env ??
  Astro.locals.runtime?.env ??
  Astro.locals?.env ??
  null;
const sessionId = Astro.cookies.get("felizNatalSession")?.value ?? null;

const formatRelativeTime = (value?: string | null) => {
  if (!value) return "";
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return "";

  const diffMilliseconds = date.getTime() - Date.now();
  const diffSeconds = Math.round(diffMilliseconds / 1000);

  const intervals: Array<{
    unit: Intl.RelativeTimeFormatUnit;
    seconds: number;
  }> = [
    { unit: "year", seconds: 31_536_000 },
    { unit: "month", seconds: 2_592_000 },
    { unit: "week", seconds: 604_800 },
    { unit: "day", seconds: 86_400 },
    { unit: "hour", seconds: 3_600 },
    { unit: "minute", seconds: 60 },
    { unit: "second", seconds: 1 },
  ];

  const rtf = new Intl.RelativeTimeFormat("pt-BR", { numeric: "auto" });

  for (const interval of intervals) {
    if (
      Math.abs(diffSeconds) >= interval.seconds ||
      interval.unit === "second"
    ) {
      const valueRounded = Math.round(diffSeconds / interval.seconds);
      return rtf.format(valueRounded, interval.unit);
    }
  }

  return "";
};

let notifications: NotificationRecord[] = [];

if (env?.DB && sessionId) {
  try {
    const result = await env.DB.prepare(
      `SELECT n.id,
			        n.title,
			        n.body,
			        n.lido,
			        n.lido_em,
			        n.created_at,
			        n.grupo_id,
			        g.slug AS grupo_slug,
			        n.mensagem_id,
			        m.is_secret AS mensagem_is_secret
			   FROM notificacao n
			   LEFT JOIN grupo g ON g.id = n.grupo_id
			   LEFT JOIN mensagem m ON m.id = n.mensagem_id
			  WHERE n.usuario_id = ?
        AND n.lido != 1
			  ORDER BY datetime(COALESCE(n.created_at, '1970-01-01')) DESC
			  LIMIT 10`
    )
      .bind(sessionId)
      .all<NotificationRecord>();

    notifications = (result?.results ?? []) as NotificationRecord[];
  } catch (error) {
    console.error("Erro ao carregar notificações:", error);
  }
}

const unreadCount = notifications.filter((item) => !item.lido).length;
const badgeCount = unreadCount;
---

<section x-data="{ open: false }" class="relative flex items-center">
  <button
    type="button"
    class="scroll-fade relative inline-flex h-11 w-11 items-center justify-center rounded-full bg-[rgba(42,157,143,0.15)] text-[var(--color-text)] hover:text-[var(--color-primary)]"
    x-bind:aria-expanded="open"
    aria-haspopup="true"
    @click="open = !open"
    @keydown.escape.window="open = false"
  >
    <svg
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 24 24"
      fill="currentColor"
      class="h-5 w-5"
    >
      <path
        d="M10.5 4.478a1.5 1.5 0 0 1 3 0 6.002 6.002 0 0 1 4.5 5.856v2.415l1.4 2.8a.75.75 0 0 1-.671 1.077H5.271a.75.75 0 0 1-.67-1.077l1.399-2.8V10.334a6.002 6.002 0 0 1 4.5-5.856zM12 22a2.5 2.5 0 0 0 2.45-2h-4.9A2.5 2.5 0 0 0 12 22z"
      ></path>
    </svg>
    {
      badgeCount ? (
        <span class="scroll-fade absolute -right-1 -top-1 inline-flex min-h-[1.25rem] min-w-[1.25rem] items-center justify-center rounded-full bg-[var(--color-primary)] px-1 text-[0.7rem] font-semibold text-[var(--color-primary-foreground)]">
          {badgeCount}
        </span>
      ) : null
    }
  </button>

  <div
    x-cloak
    x-show="open"
    x-transition:enter="transition ease-out duration-150"
    x-transition:enter-start="opacity-0 -translate-y-2"
    x-transition:enter-end="opacity-100 translate-y-0"
    x-transition:leave="transition ease-in duration-100"
    x-transition:leave-start="opacity-100 translate-y-0"
    x-transition:leave-end="opacity-0 -translate-y-2"
    @click.outside="open = false"
    class="absolute right-0 top-full z-30 mt-4 w-screen max-w-[22rem] overflow-hidden rounded-3xl border border-[var(--color-border)] bg-[var(--color-surface)] shadow-[0_12px_24px_rgba(109,76,65,0.12)] backdrop-blur"
  >
    <div
      class="flex items-center justify-between border-b border-[rgba(148,163,184,0.18)] px-5 py-4"
    >
      <p class="text-sm font-semibold text-[var(--color-text)]">Notificações</p>
    </div>

    {
      notifications.length ? (
        <ul class="divide-y divide-[rgba(148,163,184,0.12)]">
          {notifications.map((item) => {
            const relativeTime = formatRelativeTime(item.created_at ?? null);
            const isUnread = !item.lido;
            const hrefBase = item.grupo_slug
              ? `/app/grupo/${item.grupo_slug}`
              : "#";
            const isSecretMessage =
              item.title === "Mensagem Recebida" &&
              Boolean(item.mensagem_is_secret);
            const href =
              isSecretMessage && hrefBase !== "#"
                ? `${hrefBase}${hrefBase.includes("?") ? "&" : "?"}openSecret=1`
                : hrefBase;
            return (
              <li class="px-5 py-4 text-left text-xs">
                <a
                  class={[
                    "group flex flex-col gap-2 rounded-xl px-2 py-2 transition",
                    isUnread
                      ? "bg-[rgba(230,57,70,0.12)] hover:bg-[rgba(230,57,70,0.18)]"
                      : "hover:bg-[rgba(148,163,184,0.08)]",
                  ]}
                  href={href}
                  data-notification-link
                  data-notification-id={item.id}
                  data-notification-secret={
                    isSecretMessage ? "true" : undefined
                  }
                >
                  <div class="flex items-center justify-between">
                    <p class="text-[var(--color-text)]">{item.title}</p>
                    {isUnread ? (
                      <span
                        class="inline-flex h-2 w-2 rounded-full bg-[var(--color-primary)]"
                        data-notification-indicator
                      />
                    ) : null}
                  </div>
                  <p class="text-[var(--color-text-muted)] group-hover:text-[var(--color-text)]">
                    {item.body}
                  </p>
                  <p class="text-[0.65rem] uppercase tracking-[0.2em] text-[var(--color-text-muted)]">
                    {relativeTime || "há instantes"}
                  </p>
                </a>
              </li>
            );
          })}
        </ul>
      ) : (
        <div class="px-5 py-6 text-center text-xs text-[var(--color-text-muted)]">
          Nenhuma notificação por enquanto.
        </div>
      )
    }
  </div>

  <script is:inline>
    (() => {
      if (typeof window === "undefined") return;
      const endpoint = "/api/notificacoes/marcar-lida";

      const markAsRead = async (notificationId) => {
        if (!notificationId) return;
        const payload = JSON.stringify({ id: notificationId });
        try {
          const response = await fetch(endpoint, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: payload,
            credentials: "same-origin",
            keepalive: true,
          });
          return response.ok;
        } catch (error) {
          console.error("Erro ao comunicar leitura da notificação:", error);
          return false;
        }
      };

      const markAnchorAsRead = (anchor) => {
        if (!(anchor instanceof HTMLElement)) return;
        anchor.dataset.notificationRead = "true";
        anchor.classList.remove(
          "bg-[rgba(230,57,70,0.12)]",
          "hover:bg-[rgba(230,57,70,0.18)]"
        );
        anchor.classList.add("hover:bg-[rgba(148,163,184,0.08)]");
        const indicator = anchor.querySelector("[data-notification-indicator]");
        if (indicator instanceof HTMLElement) {
          indicator.remove();
        }
      };

      const withTimeout = (promise, timeoutMs) =>
        new Promise((resolve) => {
          let settled = false;
          const timer = setTimeout(() => {
            if (!settled) {
              settled = true;
              resolve(false);
            }
          }, timeoutMs);

          Promise.resolve(promise)
            .then((value) => {
              if (!settled) {
                settled = true;
                clearTimeout(timer);
                resolve(value);
              }
            })
            .catch(() => {
              if (!settled) {
                settled = true;
                clearTimeout(timer);
                resolve(false);
              }
            });
        });

      const bindListeners = () => {
        document
          .querySelectorAll("[data-notification-link]")
          .forEach((element) => {
            if (!(element instanceof HTMLElement)) return;
            if (element.dataset.notificationBound === "true") return;
            element.dataset.notificationBound = "true";

            const anchor = element;
            const getNotificationId = () =>
              anchor.getAttribute("data-notification-id") || "";

            const triggerMarkRead = async ({ immediate, navigation }) => {
              const notificationId = getNotificationId();
              if (!notificationId) return;
              markAnchorAsRead(anchor);

              if (immediate) {
                markAsRead(notificationId);
                return;
              }

              await withTimeout(markAsRead(notificationId), 350);
              if (typeof navigation === "function") {
                navigation();
              }
            };

            anchor.addEventListener("click", (event) => {
              if (!(event.currentTarget instanceof HTMLAnchorElement)) return;
              const href = event.currentTarget.getAttribute("href") || "#";
              const isModified =
                event.button !== 0 ||
                event.metaKey ||
                event.ctrlKey ||
                event.shiftKey ||
                event.altKey ||
                event.currentTarget.target === "_blank";

              if (isModified || href === "#") {
                void triggerMarkRead({ immediate: true });
                return;
              }

              event.preventDefault();
              void triggerMarkRead({
                immediate: false,
                navigation: () => {
                  window.location.assign(href);
                },
              });
            });

            anchor.addEventListener("auxclick", (event) => {
              if (event.button === 1 || event.button === 2) {
                void triggerMarkRead({ immediate: true });
              }
            });

            anchor.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                const href = anchor.getAttribute("href") || "#";
                void triggerMarkRead({
                  immediate: false,
                  navigation: () => {
                    if (href !== "#") {
                      window.location.assign(href);
                    }
                  },
                });
              }
            });
          });
      };

      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", bindListeners, {
          once: true,
        });
      } else {
        bindListeners();
      }

      document.addEventListener("htmx:afterSwap", bindListeners);
    })();
  </script>
</section>
